<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Edit Wiki - OpenST</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown-dark.css">

    <style>
        :root { --brand-color: #40B5AD; --bg-deep: #0c0c0c; }
        body { background-color: var(--bg-deep); color: #e0e0e0; font-family: 'Inter', system-ui, sans-serif; overflow: hidden; height: 100dvh; }

        .glass-panel { background: rgba(255, 255, 255, 0.01); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 24px; }
        .cyber-btn { background: var(--brand-color); color: #000; font-weight: 800; transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1); }
        .cyber-btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 0 20px rgba(64, 181, 173, 0.4); }
        .cyber-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        .markdown-body { background: transparent !important; font-size: 14px; line-height: 1.8; color: rgba(255,255,255,0.8); }
        .markdown-body img { border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); max-width: 100%; }

        .no-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; }
        .no-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }

        /* å“åº”å¼æ ¸å¿ƒï¼šç§»åŠ¨ç«¯ä¸Šä¸‹æ’åˆ— */
        @media (max-width: 1024px) {
            main { flex-direction: column !important; }
            .resizer { display: none !important; }
            section { width: 100% !important; flex: 1 1 50% !important; }
            .glass-panel { border-radius: 12px; }
            header { padding: 0.5rem !important; }
        }

        .resizer { width: 1px; background: rgba(255,255,255,0.05); margin: 0 4px; }
        input::placeholder { color: rgba(255,255,255,0.2); }
    </style>
</head>
<body>

<div id="editor-app" class="h-full w-full flex flex-col p-3 lg:p-6">

    <header class="flex justify-between items-center mb-4 px-2">
        <div class="flex items-center gap-3 flex-1 min-w-0">
            <a href="wiki.html" class="text-[10px] font-black tracking-[0.3em] text-white/20 hover:text-[#40B5AD] transition-all uppercase">Exit</a>
            <div class="h-4 w-px bg-white/10"></div>

            <div class="flex items-center gap-1 min-w-0 overflow-hidden">
                <span class="text-[10px] font-mono text-white/20 uppercase hidden sm:inline">Editing:</span>
                <template v-if="isNewFile">
                    <input v-model="newFileName" placeholder="file-name"
                           class="bg-transparent border-b border-[#40B5AD]/30 outline-none font-mono text-sm text-[#40B5AD] w-32 sm:w-48 focus:border-[#40B5AD]">
                </template>
                <span v-else class="text-[#40B5AD] text-sm font-mono truncate">{{ filePath }}</span>
                <span class="text-white/20 text-xs">.md</span>
            </div>
        </div>

        <button @click="submitEdit" :disabled="loading || !content.trim() || (isNewFile && !newFileName.trim())"
                class="cyber-btn px-5 py-2 rounded-lg text-[10px] ml-2">
            {{ loading ? 'WAIT' : 'COMMIT' }}
        </button>
    </header>

    <main class="flex-1 flex glass-panel overflow-hidden">
        <section class="flex-1 flex flex-col min-w-0 border-r border-white/5">
            <div class="px-4 py-2 border-b border-white/5 text-[9px] text-white/20 font-mono tracking-widest uppercase flex justify-between items-center bg-white/[0.01]">
                <span>Markdown Source</span>
                <span class="hidden sm:inline">{{ content.length }} chars</span>
            </div>
            <textarea
                    ref="editorTextarea"
                    v-model="content"
                    @scroll="handleScroll"
                    spellcheck="false"
                    placeholder="Start writing..."
                    class="flex-1 w-full p-5 lg:p-8 bg-transparent outline-none font-mono text-sm leading-relaxed text-white/70 resize-none no-scrollbar">
            </textarea>
        </section>

        <div class="resizer"></div>

        <section class="flex-1 flex flex-col min-w-0 bg-white/[0.005]">
            <div class="px-4 py-2 border-b border-white/5 text-[9px] text-[#40B5AD] font-mono tracking-widest uppercase bg-white/[0.01]">
                Live Preview
            </div>
            <div
                    ref="previewArea"
                    v-html="previewHtml"
                    class="markdown-body flex-1 w-full p-5 lg:p-8 overflow-y-auto no-scrollbar">
            </div>
        </section>
    </main>

    <footer class="mt-3 flex flex-col sm:flex-row items-center justify-between gap-3 px-2">
        <div class="flex items-center gap-3 w-full sm:w-auto overflow-hidden">
            <label class="shrink-0 cursor-pointer">
                <input type="file" multiple accept="image/*" @change="handleImageSelect" class="hidden">
                <div class="px-3 py-2 bg-white/5 hover:bg-[#40B5AD]/20 border border-white/10 rounded-lg transition-all text-[9px] font-black text-white/40 uppercase tracking-widest">
                    Add Images
                </div>
            </label>

            <div class="flex gap-2 overflow-x-auto no-scrollbar py-1">
                <div v-for="(file, index) in imageFiles" :key="file.name"
                     class="group relative w-10 h-10 shrink-0">
                    <img :src="imageMap[file.name]" @click="insertImageLink(file.name)"
                         class="w-full h-full object-cover rounded border border-white/10 cursor-pointer hover:border-[#40B5AD] opacity-60 hover:opacity-100">
                    <div @click.stop="removeImage(index)"
                         class="absolute -top-1 -right-1 w-3 h-3 bg-red-500/80 text-white text-[8px] flex items-center justify-center rounded-full cursor-pointer shadow-lg">
                        Ã—
                    </div>
                </div>
            </div>
        </div>

        <div v-if="user" class="text-[8px] font-mono text-white/10 tracking-widest">
            ID: <span class="text-white/30">{{ user.login.toUpperCase() }}</span>
        </div>
    </footer>
</div>

<script>
    const { createApp } = Vue;
    const WORKER_URL = "https://openstsubmission.linvin.net";
    const WIKI_BASE = "/content";

    createApp({
        data() {
            let pathParam = new URLSearchParams(window.location.search).get('path') || '/README';
            if (pathParam === '/') pathParam = '/README';

            return {
                filePath: pathParam,
                isNewFile: pathParam === '/NEW_DOCUMENT',
                newFileName: '',
                content: '',
                loading: false,
                user: null,
                token: null,
                imageFiles: [],
                imageMap: {}
            }
        },
        computed: {
            previewHtml() {
                let raw = this.content || '*No content to preview*';
                const processed = raw.replace(/!\[(.*?)\]\((?!http)(.*?)\)/g, (match, alt, filename) => {
                    const localBlob = this.imageMap[filename];
                    return localBlob ? `![${alt}](${localBlob})` : match;
                });
                return marked.parse(processed);
            }
        },
        async mounted() {
            this.checkAuth();
            if (!this.isNewFile) {
                this.loading = true;
                const normalizedPath = this.filePath.startsWith('/') ? this.filePath : '/' + this.filePath;
                const targetUrl = `${window.location.origin}/wiki${WIKI_BASE}${normalizedPath}.md`;
                try {
                    const res = await fetch(targetUrl);
                    this.content = res.ok ? await res.text() : "# Not Found\nCreating new content...";
                } catch (e) { this.content = "# Load Error"; }
                finally { this.loading = false; }
            }
        },
        methods: {
            checkAuth() {
                const raw = localStorage.getItem('gh_auth');
                if (!raw) {
                    window.location.href = 'wiki.html';
                    return;
                }

                try {
                    const authData = JSON.parse(raw);
                    console.log("æ£€æµ‹åˆ°ç™»å½•æ•°æ®:", authData);
                    this.token = authData.token || authData.access_token;
                    this.user = authData.user || { login: 'Unknown' };
                    if (!this.token) {
                        alert("ç™»å½•ä¿¡æ¯ç¼ºå¤±ä»¤ç‰Œï¼Œè¯·å°è¯•é‡æ–°ç™»å½•");
                        window.location.href = 'wiki.html';
                    }
                } catch (e) {
                    console.error("è§£æç™»å½•ä¿¡æ¯å¤±è´¥", e);
                    window.location.href = 'wiki.html';
                }
            },
            handleImageSelect(e) {
                const files = Array.from(e.target.files);
                const totalSize = files.reduce((acc, f) => acc + f.size, 0);
                if (totalSize > 50 * 1024 * 1024) return alert("Total size exceeds 50MB limit!");

                this.imageFiles = [...this.imageFiles, ...files];
                files.forEach(file => {
                    this.imageMap[file.name] = URL.createObjectURL(file);
                });
            },
            removeImage(index) {
                const name = this.imageFiles[index].name;
                URL.revokeObjectURL(this.imageMap[name]);
                delete this.imageMap[name];
                this.imageFiles.splice(index, 1);
            },
            insertImageLink(name) {
                const el = this.$refs.editorTextarea;
                const start = el.selectionStart;
                const end = el.selectionEnd;
                const tag = `![Description](${name})`;
                this.content = this.content.substring(0, start) + tag + this.content.substring(end);
                this.$nextTick(() => {
                    el.focus();
                    el.setSelectionRange(start + 2, start + 13);
                });
            },
            handleScroll(e) {
                const previewEl = this.$refs.previewArea;
                const ratio = e.target.scrollTop / (e.target.scrollHeight - e.target.clientHeight);
                previewEl.scrollTop = ratio * (previewEl.scrollHeight - previewEl.clientHeight);
            },
            async submitEdit() {
                let baseName = this.isNewFile
                    ? this.newFileName.trim().replace(/[^a-zA-Z0-9-_\u4e00-\u9fa5]/g, '-')
                    : this.filePath.replace(/^\//, '').replace('.md', '');

                if (!baseName) return alert("Invalid filename");
                this.loading = true;

                try {
                    const zip = new JSZip();
                    const folder = zip.folder(baseName);
                    folder.file(`${baseName}.md`, this.content);
                    this.imageFiles.forEach(f => folder.file(f.name, f));

                    const zipBlob = await zip.generateAsync({type: "blob"});
                    const zipFileName = `${this.isNewFile ? 'wiki-submission' : 'wiki-modify'}-${baseName}.zip`;

                    const fd = new FormData();
                    fd.append('file', zipBlob, zipFileName);
                    fd.append('user', this.user.login);
                    fd.append('path', `wiki/contents/${baseName}`);
                    fd.append('title', `[Wiki ${this.isNewFile ? 'New' : 'Edit'}] ${baseName}`);

                    const res = await fetch(`${WORKER_URL}/api/wiki/submit-archive`, {
                        method: 'POST',
                        headers: {'Authorization': `Bearer ${this.token}`},
                        body: fd
                    });

                    if (res.ok) {
                        const data = await res.json();
                        const issueNum = data.issueNumber || data.number;

                        if (issueNum) {
                            alert(`ğŸ‰ æäº¤æˆåŠŸï¼Issue #${issueNum} å·²åˆ›å»ºã€‚`);
                            window.location.href = `https://github.com/MC-OpenST/submissions/issues/${issueNum}`;
                        } else {
                            alert(`âš ï¸ GitHub æœªèƒ½è¿”å›ç¼–å·ï¼š\n${JSON.stringify(data)}`);
                        }
                    } else {
                        const errorMsg = await res.text();
                        alert("âŒ Worker è½¬å‘å¤±è´¥: " + errorMsg);
                    }
                } catch (err) {
                    alert("âŒ è„šæœ¬æ‰§è¡Œé”™è¯¯: " + err.message);
                } finally {
                    this.loading = false;
                }
            }
        }
    }).mount('#editor-app');
</script>
</body>
</html>